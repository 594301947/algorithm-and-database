面试官一般想让我们写出非递归版本

int fibonaciRecu(int N){  //递归版本
	if (N <= 0)
		return 0;
	else if (N == 1 || N == 2)
		return 1;
	else
		return fibonaciRec(N - 1) + fibonaciRec(N - 2);
}

int fibonaci(int N){ //非递归版本
	if (N <= 0)
		return 0;
	if (N == 1 || N == 2)
		return 1;
	//N必然大于2
	int a = 1, b = 1, ret;
	for (int i = 3; i <= N; i++){
		ret = a + b;
		a = b; b = ret; //更新a和b
	}
	return ret;
}

==============

剑指OFFER之矩形覆盖（九度OJ1390）
    https://www.cnblogs.com/xing901022/p/3753718.html

用2*1的小矩形横着或者竖着去覆盖更大的矩形。
详细：请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？

解题思路：
　　观察题目中的矩形，2*n的，是个长条形。本来脑中想象的是复杂的华容道，但是既然只是简单的长条形，那么依然"逆向分析"。
既然是长条形的，那么"从后向前"。
  为了避免重复覆盖，2*N的矩形只能分成下面两种情况：
    情况(1) 2*(N-1)的矩形 + 2*1的矩形
    情况(2) 2*(N-2)的矩形 + 两个1*2的矩形  { 2*(N-2)的矩形 + 两个2*1的矩形,与情况(1)重复 }
  因此：
    F(N)=F(N-1)+F(N-2)
又因为：
    F(1)=1
    F(2)=2
综上所述，
    F(1)=1
    F(2)=2
    F(N)=F(N-1)+F(N-2)

天啊！这和{斐波那契数列}一摸一样啊！
