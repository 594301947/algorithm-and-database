
/*
5.1链表局部反转: reverse(left,start,end,right)
8.判断一个链表是否是回文***
9.复制rand指针的单链表
*/

#include<assert.h>
#include<unordered_set>
#include<stack>
#include<iostream>
using namespace std;
typedef struct LinkNode{
	struct LinkNode* next;
	struct LinkNode* rand;
	int data;
}LinkNode;
//1.创建节点
LinkNode* createLink(){
	LinkNode* head = (LinkNode*)malloc(sizeof(LinkNode));
	head->next = NULL;
	LinkNode* ptr = head;
	int data;
	while (1){
		cout << "请输入data=";
		cin >> data;
		if (data == -1)
			break;
		//创建新节点
		LinkNode* newNode = (LinkNode*)malloc(sizeof(LinkNode));
		newNode->data = data;
		newNode->next = NULL;
		//在尾部插入新节点newNode
		ptr->next = newNode;
		//ptr指针指向新的尾部节点
		ptr = newNode;
	}
	return head;
}
void reverse_start_end(LinkNode* left, LinkNode* start, LinkNode* end, LinkNode* right){
	//3.反转局部链表[from,to],要使用四个变量[start,from,to,end]
	LinkNode* pre = NULL;
	LinkNode* cur = start;
	while (cur != right){
		LinkNode* post = cur->next;
		cur->next = pre;//反指
		pre = cur; cur = post;//更新pre和cur，后移
	}
	//4.重新连接
	left->next = end;
	start->next = right;
}
void reversePart(LinkNode*& head, LinkNode* start, LinkNode* end){
	if (head == NULL || start == NULL || end == NULL || start >= end)
		return;
	LinkNode* left = searchPre(head, start);//1.from的前驱
	if (left == NULL) //如果没找到from，则直接返回，不做任何处理
		return;
	LinkNode* right = end->next; //2.end的后继
	//反转[start,end]
	reverse_start_end(left, start, end, right);
}
//10.判断链表是否为回文:O(N)  O(N/2)  O(1)
//方法1：空间复杂度O(N)
bool isPlalindrome1(LinkNode* head){
	assert(head != NULL);
	if (head->next == NULL)
		return true;

	stack<LinkNode*> S;
	LinkNode* cur = head->next;
	while (cur != NULL){ //1.将链表的有效节点依次入栈
		S.push(cur);
		cur = cur->next;
	}
	cur = head->next;//重置cur
	while (!S.empty()){ //如果栈不空
		LinkNode* topNode = S.top();
		//2.判断（获取栈顶元素==cur）
		if (topNode->data != cur->data) //如果有一个不同，就不是回文
			return false;
		S.pop(); cur = cur->next;
	}
	return true;
}
//方法2：空间复杂度O(N/2)
bool isPlalindrome2(LinkNode* head){
	assert(head != NULL);
	if (head->next == NULL)
		return true;
	LinkNode* slow = head->next;
	LinkNode* fast = head->next->next;
	//1.寻找第中间节点slow
	while (fast&&fast->next){
		fast = fast->next->next;
		slow = slow->next->next;
	}
	stack<int> S; //2.将链表的右半部分入栈
	while (slow){
		S.push(slow->data);
		slow = slow->next;
	}
	fast = head->next; //fast指向head->next
	//3.（将栈中元素）依次与（链表左半部分元素）比对
	while (!S.empty()){
		if (S.top() != fast->data)
			return false;
		S.pop(); fast = fast->next;//比对下一个元素
	}
	return true;
}
/*
方法3：
	1-->2-->3-->2-->1    1-->2-->2-->1
	1-->2-->3<--2<--1    1-->2<--2<--1
*/

//11.复制rand指针的单链表
// head-->1-->2-->3-->4-->null
// head-->1-->1'-->2-->2'-->3-->3'-->4-->4'-->null
// [return] 1'-->2'-->3'-->4'-->null
LinkNode* CopyRandLink(LinkNode* head){
	if (head == NULL || head->next == NULL)
		return head;
	//1.第一次遍历：拷贝每个节点
	LinkNode* cur = head->next;
	while (cur != NULL){
		//(1)创建新节点
		LinkNode* newNode = (LinkNode*)malloc(sizeof(LinkNode));
		newNode->data = cur->data; newNode->rand = NULL;
		//(2)插入新节点
		newNode->next = cur->next; cur->next = newNode;
		//(3)后移
		cur = cur->next->next;
	}
	//2.第二次遍历：复制rand指针域
	cur = head->next;
	while (cur != NULL){
		//拷贝rand指针域的指向：注意rand是NULL的情况
		cur->next->rand = (cur->rand == NULL) ? (NULL) : cur->rand->next;
		cur = cur->next->next;//向后遍历
	}
	//3.第三次遍历：拆分
	cur = head->next;    LinkNode* ret = cur->next;
	while (cur != NULL){
		LinkNode* tmp = cur->next; //保存
		cur = cur->next->next;
		tmp->next = (cur == NULL) ? NULL : cur->next;//注意cur==NULL的情况
	}
	return ret;
}

//遍历
void travel(LinkNode* head){
	LinkNode* cur = head->next;//cur指向第一个有效节点
	while (cur){
		cout << cur->data << "  ";
		cur = cur->next;
	}
	system("pause");
}


void test08(){  //复制带有rand指针的链表
	LinkNode* head = (LinkNode*)malloc(sizeof(LinkNode));
	LinkNode* node1 = (LinkNode*)malloc(sizeof(LinkNode));
	LinkNode* node2 = (LinkNode*)malloc(sizeof(LinkNode));
	LinkNode* node3 = (LinkNode*)malloc(sizeof(LinkNode));
	LinkNode* node4 = (LinkNode*)malloc(sizeof(LinkNode));
	head->next = node1;
	node1->next = node2; node1->rand = node3; node1->data = 1;
	node2->next = node3; node2->rand = node1; node2->data = 2;
	node3->next = node4; node3->rand = node1; node3->data = 3;
	node4->next = NULL; node4->rand = NULL; node4->data = 4;

	LinkNode* ret = CopyRandLink(head);
	system("pause");
}

int main(){
	test08();
	system("pause");
}
