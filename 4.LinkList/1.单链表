#include<assert.h>
#include<unordered_set>
#include<stack>
#include<iostream>
using namespace std;
typedef struct LinkNode{
	struct LinkNode* next;
	struct LinkNode* rand;
	int data;
}LinkNode;
//1.创建节点
LinkNode* createLink(){
	LinkNode* head = (LinkNode*)malloc(sizeof(LinkNode));
	head->next = NULL;
	LinkNode* ptr = head;
	int data;
	while (1){
		cout << "请输入data=";
		cin >> data;
		if (data == -1)
			break;
		//创建新节点
		LinkNode* newNode = (LinkNode*)malloc(sizeof(LinkNode));
		newNode->data = data;
		newNode->next = NULL;
		//在尾部插入新节点newNode
		ptr->next = newNode;
		//ptr指针指向新的尾部节点
		ptr = newNode;
	}
	return head;
}
//2.获取中间节点
//靠前
LinkNode* getMidNode(LinkNode* head){
	if (head == NULL || head->next == NULL) //链表没有有效节点,返回NULL
		return NULL;
	LinkNode* slow = head->next;  //slow指向第一个有效节点
	LinkNode* fast = head->next->next; //fast指向第二个有效节点
	while (fast&&fast->next){
		slow = slow->next;
		fast = fast->next->next;
	}
	return slow;
}
//靠后
LinkNode* getMidNode_2(LinkNode* head){//第[n/2向下取整]个有效节点: 
	if (head == NULL || head->next == NULL) //链表没有有效节点,返回NULL
		return NULL;
	LinkNode* slow = head;  //slow指向第一个有效节点
	LinkNode* fast = head; //fast指向第二个有效节点
	while (fast&&fast->next){
		slow = slow->next;
		fast = fast->next->next;
	}
	return slow;
}

/*3.
判断单链表是否有环：
如果有，返回入环的第一个点
如果没有，返回NULL
*/
LinkNode* isLoop(LinkNode* head){
	if (!head)
		return NULL;
	LinkNode* slow = head;
	LinkNode* fast = head;
	while (fast&&fast->next){ //如果fast走到末尾，跳出while
		slow = slow->next;
		fast = fast->next->next;
		if (slow == fast) //如果slow==fast时，相撞，跳出while
			break;
	}
	if (slow != fast)//判断是不是fast/slow相撞才退出循环？
		return NULL;
	//在相遇位置，使快指针指向head，之后快慢指针都一次走一步，下一次相交点就是第一个入环点
	fast = head;
	while (fast != slow){
		fast = fast->next;
		slow = slow->next;
	}
	return slow;
}
/*
4.有序链表的合并:将L2中的节点c2,插入到L1中
	实际上，是将L2中的c2插入到L1的p1和c1之间
*/
LinkNode* mergeL1L2(LinkNode* L1, LinkNode* L2){
	if (L1 == NULL)
		return L2;
	else if (L2 == NULL)
		return L1;

	//p1和p2指向头节点有效节点
	LinkNode* p1 = L1;
	LinkNode* p2 = L2;
	//c1和c2指向第一个有效节点
	LinkNode* c1 = L1->next;
	LinkNode* c2 = L2->next;

	while (c1 && c2){
		if (c1->data > c2->data){//将c2插入到L1中
			//L1中删除c2
			p2->next = c2->next;
			//将c2插入到L1中
			c2->next = c1; p1->next = c2;
			c2 = p2->next; //更新c2
			p1 = p1->next; //不要忘记L1中插入元素后,p1后移
		}
		else{
			p1 = c1; c1 = c1->next;
		}
	}
	if (p2 != NULL)
		p1->next = c2;
	return L1;
}
//5.单链表的倒置
LinkNode* reverse(LinkNode* head){
	if (head == NULL)
		return NULL;
	if (head->next == NULL)
		return head;

	LinkNode* pre = NULL;
	LinkNode* cur = head->next; //第一个有效节点
	while (cur){
		LinkNode* post = cur->next;
		cur->next = pre;
		pre = cur; cur = post;
	}
	head->next = pre;
	return head;
}
LinkNode* searchPre(LinkNode* head, LinkNode* node){ //查找node的前驱
	if (head == NULL || node == NULL)
		return NULL;
	LinkNode* cur = head->next;
	LinkNode* pre = NULL;
	while (cur != NULL){
		if (cur != node){
			pre = cur;
			cur = cur->next;
		}
		else
			return pre;
	}
	return NULL;
}

void reverse_start_end(LinkNode* left, LinkNode* start, LinkNode* end, LinkNode* right){
	//3.反转局部链表[from,to],要使用四个变量[start,from,to,end]
	LinkNode* pre = NULL;
	LinkNode* cur = start;
	while (cur != right){
		LinkNode* post = cur->next;
		cur->next = pre;//反指
		pre = cur; cur = post;//更新pre和cur，后移
	}
	//4.重新连接
	left->next = end;
	start->next = right;
}
void reversePart(LinkNode*& head, LinkNode* start, LinkNode* end){
	if (head == NULL || start == NULL || end == NULL || start >= end)
		return;
	LinkNode* left = searchPre(head, start);//1.from的前驱
	if (left == NULL) //如果没找到from，则直接返回，不做任何处理
		return;
	LinkNode* right = end->next; //2.end的后继
	//反转[start,end]
	reverse_start_end(left, start, end, right);
}

//7.查找
LinkNode* searchData(LinkNode* head, int key){
	assert(head != NULL);
	LinkNode* cur = head->next; //指向第一个节点
	while (cur){
		if (cur->data == key){
			return cur;
		}
		cur = cur->next;
	}
	return NULL;
}
//8.打印两个链表的公共部分
void printCommonPart(LinkNode* L1, LinkNode* L2){
	assert((L1 != NULL) && (L2 != NULL));
	LinkNode* c1 = L1; LinkNode* c2 = L2;
	while (c1 != NULL&&c2 != NULL){ //如果相等，c1/c2都后移
		if (c1->data == c2->data){
			c1 = c1->next; c2 = c2->next;
			cout << c1->data << "  ";
		}
		else if (c1->data < c2->data) //如果不等，小的后移
			c1 = c1->next;
		else
			c2 = c2->next;
	}
}
//9.1查找倒数第K个节点
LinkNode* GetLastKthNode(LinkNode* head, int lastKth){
	if (head == NULL || head->next == NULL || lastKth <= 0)
		return NULL;
	LinkNode* p = head;
	LinkNode* q = head;
	while (p && lastKth > 0){ //先让p走(lastKth-1)步，走到第lastKth位置
		p = p->next;
		lastKth--;
	}
	if (lastKth > 0)  //如果p已经到中终点，lastKth仍然>0--->lastKth越界
		return NULL;
	while (p){  //此时p和q一起走，当直到p为NULL时，q的位置就是倒数第lastKth个节点位置
		p = p->next;
		q = q->next;
	}
	return q;
}
//9.2删除倒数第K个节点
void RemoveLastKthNode(LinkNode* head, int lastKth){
	//查找倒数第K+1个节点的位置(即倒数第K个节点的前驱)
	LinkNode* pre = GetLastKthNode(head, lastKth + 1);
	if (!pre) //如果没找到
		return;
	LinkNode* deleteNode = pre->next;
	//删除deleteNode
	pre->next = deleteNode->next; delete(deleteNode); deleteNode = NULL;
}
//10.判断链表是否为回文:O(N)  O(N/2)  O(1)
//方法1：空间复杂度O(N)
bool isPlalindrome1(LinkNode* head){
	assert(head != NULL);
	if (head->next == NULL)
		return true;

	stack<LinkNode*> S;
	LinkNode* cur = head->next;
	while (cur != NULL){ //1.将链表的有效节点依次入栈
		S.push(cur);
		cur = cur->next;
	}
	cur = head->next;//重置cur
	while (!S.empty()){ //如果栈不空
		LinkNode* topNode = S.top();
		//2.判断（获取栈顶元素==cur）
		if (topNode->data != cur->data) //如果有一个不同，就不是回文
			return false;
		S.pop(); cur = cur->next;
	}
	return true;
}
//方法2：空间复杂度O(N/2)
bool isPlalindrome2(LinkNode* head){
	assert(head != NULL);
	if (head->next == NULL)
		return true;
	LinkNode* slow = head->next;
	LinkNode* fast = head->next->next;
	//1.寻找第中间节点slow
	while (fast&&fast->next){
		fast = fast->next->next;
		slow = slow->next->next;
	}
	stack<int> S; //2.将链表的右半部分入栈
	while (slow){
		S.push(slow->data);
		slow = slow->next;
	}
	fast = head->next; //fast指向head->next
	//3.（将栈中元素）依次与（链表左半部分元素）比对
	while (!S.empty()){
		if (S.top() != fast->data)
			return false;
		S.pop(); fast = fast->next;//比对下一个元素
	}
	return true;
}
/*
方法3：
1-->2-->3-->2-->1    1-->2-->2-->1
1-->2-->3<--2<--1    1-->2<--2<--1
*/

//11.复制rand指针的单链表
// head-->1-->2-->3-->4-->null
// head-->1-->1'-->2-->2'-->3-->3'-->4-->4'-->null
// [return] 1'-->2'-->3'-->4'-->null
LinkNode* CopyRandLink(LinkNode* head){
	if (head == NULL || head->next == NULL)
		return head;
	//1.第一次遍历：拷贝每个节点
	LinkNode* cur = head->next;
	while (cur != NULL){
		//(1)创建新节点
		LinkNode* newNode = (LinkNode*)malloc(sizeof(LinkNode));
		newNode->data = cur->data; newNode->rand = NULL;
		//(2)插入新节点
		newNode->next = cur->next; cur->next = newNode;
		//(3)后移
		cur = cur->next->next;
	}
	//2.第二次遍历：复制rand指针域
	cur = head->next;
	while (cur != NULL){
		//拷贝rand指针域的指向：注意rand是NULL的情况
		cur->next->rand = (cur->rand == NULL) ? (NULL) : cur->rand->next;
		cur = cur->next->next;//向后遍历
	}
	//3.第三次遍历：拆分
	cur = head->next;    LinkNode* ret = cur->next;
	while (cur != NULL){
		LinkNode* tmp = cur->next; //保存
		cur = cur->next->next;
		tmp->next = (cur == NULL) ? NULL : cur->next;//注意cur==NULL的情况
	}
	return ret;
}
//12.删除无序链表中重复的值1-->2-->3-->3-->4-->2-->1-->null
/*方法1：类似于插入排序——时间复杂度O(N*N)，空间复杂度O(1)
首先检查第一个有效节点1；然后向后依次遍历值为1的节点，删除
检查第二个有效节点2；然后向后依次遍历值为2的节点，删除
...
*/
//方法2：哈希表——时间复杂度O(N),空间复杂度O(N)
void RemoveRep(LinkNode*& head){
	if (head == NULL || head->next == NULL)
		return;
	unordered_set<int> set;
	set.insert(head->next->data);  //将第一个值放入哈希表

	LinkNode* pre = head->next;
	LinkNode* cur = head->next->next;
	while (cur != NULL){
		unordered_set<int>::iterator iter = set.find(cur->data);
		if (iter == set.end()) {//哈希表中没有,不删除（直接后移）
			set.insert(cur->data); //cur->data插入哈希表
			pre = cur; cur = cur->next;
		}
		else{ //哈希表中有,删除cur
			LinkNode* tmp = cur;
			pre->next = pre->next->next; free(tmp);
			cur = pre->next;
		}
	}
}
void RemoveValue(LinkNode*& head, int num){
	if (head == NULL || head->next == NULL)
		return;
	LinkNode* pre = head;
	LinkNode* cur = head->next;
	while (cur != NULL){
		if (cur->data == num){
			LinkNode* tmp = cur;
			pre->next = pre->next->next; free(tmp);
			cur = pre->next;
		}
		else{
			pre = cur; cur = cur->next;
		}
	}
}
//遍历
void travel(LinkNode* head){
	LinkNode* cur = head->next;//cur指向第一个有效节点
	while (cur){
		cout << cur->data << "  ";
		cur = cur->next;
	}
	system("pause");
}

void test01(){//查找中间节点
	LinkNode* head = createLink();
	LinkNode* mid = getMidNode(head);
	head = reverse(head);
	travel(head);
	system("pause");
}
void test02(){  //环形单链表
	LinkNode* head = (LinkNode*)malloc(sizeof(LinkNode));
	LinkNode* node1 = (LinkNode*)malloc(sizeof(LinkNode));
	LinkNode* node2 = (LinkNode*)malloc(sizeof(LinkNode));
	LinkNode* node3 = (LinkNode*)malloc(sizeof(LinkNode));
	LinkNode* node4 = (LinkNode*)malloc(sizeof(LinkNode));
	head->next = node1;
	node1->next = node2; node1->data = 1;
	node2->next = node3; node2->data = 2;
	node3->next = node4; node3->data = 3;
	node4->next = node3; node4->data = 4;

	LinkNode* ret = isLoop(head);
	if (ret != NULL)
		printf("%d\n", ret->data);

	system("pause");
}
void test03(){ //有序表的合并
	LinkNode* L1 = createLink();
	LinkNode* L2 = createLink();
	LinkNode* L3 = mergeL1L2(L1, L2);
	travel(L3);
}
void test04(){ //删除节点
	LinkNode* L1 = createLink();
	RemoveLastKthNode(L1, 3);
	travel(L1);
}
void test05(){  //查找
	LinkNode* head = createLink();
	LinkNode* ret = searchData(head, 10);
	if (ret == NULL)
		cout << "没查找到" << endl;
	else
		cout << ret->data << endl;
	system("pause");
}
void test06(){ //链表局部反转
	LinkNode* head = createLink();
	LinkNode* from = head->next->next;
	LinkNode* to = from->next->next->next;
	reversePart(head, from, to);
	travel(head);
}
void test07(){
	LinkNode* head = createLink();
	bool ret1 = isPlalindrome1(head);
	bool ret2 = isPlalindrome2(head);
}
void test08(){  //复制带有rand指针的链表
	LinkNode* head = (LinkNode*)malloc(sizeof(LinkNode));
	LinkNode* node1 = (LinkNode*)malloc(sizeof(LinkNode));
	LinkNode* node2 = (LinkNode*)malloc(sizeof(LinkNode));
	LinkNode* node3 = (LinkNode*)malloc(sizeof(LinkNode));
	LinkNode* node4 = (LinkNode*)malloc(sizeof(LinkNode));
	head->next = node1;
	node1->next = node2; node1->rand = node3; node1->data = 1;
	node2->next = node3; node2->rand = node1; node2->data = 2;
	node3->next = node4; node3->rand = node1; node3->data = 3;
	node4->next = NULL; node4->rand = NULL; node4->data = 4;

	LinkNode* ret = CopyRandLink(head);
	system("pause");
}
void test09(){ //无序单链表的去重
	LinkNode* head = createLink();
	RemoveRep(head);
	travel(head);
}
void test10(){
	LinkNode* head = createLink();
	RemoveValue(head, 10);
	travel(head);
}

int main(){
	test03();
	system("pause");
}
