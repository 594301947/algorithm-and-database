题目：求由数字1围成的岛的个数
	1, 0, 0, 0, 0,
	0, 1, 0, 0, 1,
	0, 0, 1, 0, 1

解法1：递归（感染）——单CPU：小矩形

void infect(int (*A)[5], int i, int j, int M, int N){
	//保证坐标有效，A[i][j]=1,才去感染
	if (i < 0 || j < 0 || i >= M || j >= N || A[i][j] != 1) 
		return;
	A[i][j] = 2; //感染时，将值从1改成2
	
	//开始递归感染
	infect(A, i + 1, j, M, N); //向右感染
	infect(A, i - 1, j, M, N); //向左感染
	infect(A, i, j + 1, M, N); //向下感染
	infect(A, i, j - 1, M, N); //向上感染
}
int countIsLands(int (*A)[5],int M,int N){
	int res = 0; //岛的个数
	//从左到右，从上到下遍历每一个元素
	for (int i = 0; i < M; i++){
		for (int j = 0; j < N; j++){
			if (A[i][j] == 1){ //如果当前元素为1
				infect(A, i, j, M, N); //开始感染周围的元素全部变成2
				res++;//感染完成后，res++
			}
		}
	}
	return res;//返回res
}
void test(){
	int A[3][5] = {  //求1围成的岛的个数
		1, 0, 0, 0, 0,
		0, 1, 0, 0, 1,
		0, 0, 1, 0, 1
	};
	int ret = countIsLands(A, 3, 5);
}
int main(){
	test();
}

解法2：假设矩形非常非常大，要求采用多CPU并行的方式求岛的个数
(1)将大矩形进行切割，分成多块小矩形（以切分成两个矩形块A和B为例）
(2)分别对每一个小矩形A和B计算3个信息：
	每个矩形的岛个数Anum和Bnum
	边界的感染源是谁
(3)矩形块A和矩形块B合并，求岛的个数
      1.用并查集，依次比较两块矩形的边界的感染源是否在同一个集合中？（设置合并次数变量cnt）
      	  如果感染源不在一个集合中：将感染源合并，同时cnt++；向后遍历
	  如果感染源在同一个集合中：不执行处理，直接向后遍历
      2.岛的个数=Anum+Bnum-cnt
	  

