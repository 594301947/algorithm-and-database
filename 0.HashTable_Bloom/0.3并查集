并查集：解决的两个问题
  (1)非常快的查询两个元素是否属于同一个集合: bool isSameSet(int data1,int data2);
        思路：先通过data1找到set1；然后在set1中查询是否存在data2
  (2)如果两个数据不在同一个集合中，则将两个集合合并: void union(int data1,int data2);
        思路：通过data1和data2查找到各自所在的集合set1和set2，然后将set1和set2合并
      
========================================================

背景：使用list或者hashtable不能实现！
    list:虽然合并set1和set2非常快；但是查询data2是否在data1的集合中，需要遍历
    hashtable：虽然查询data2是否在data1的集合中使用O(1)时间；但是将set1和set2合并时，set1中的每
               个元素都要通过哈希函数计算哈希码，再mod M，放到set2中相应的位置。
               
========================================================

并查集：
[1]两种节点
    (1)代表节点：指向自身
    (2)普通节点：指向代表节点或者指向下一个普通节点；但是一直向下指，都会指向代表节点
[2]每个集合都有唯一的代表节点
    (1)判断两个节点是否属于同一个集合：两个节点分别向后遍历，找到代表节点，判断代表节点是否相同
    (2)将两个集合合并：两个集合的代表节点合并（将短的集合"挂到"长的集合中）

唯一的优化：
    在查找某个节点是否属于集合时，在向后遍历节点的同时，直接将该节点指向代表节点

举例说明：
  此时有4个代表节点，分别是1',2',3',4'
要求：
(1)先将1'和2'合并，3'和4'合并
    直接将2挂在1'的下面，2变成普通节点
    直接将4挂在3'的下面，4变成普通节点
(2)查询2和4是否在同一个集合
    从节点2开始，依次向后遍历（遍历的同时，将节点变"扁平"），直到找到代表节点1'
    从节点4开始，依次向后遍历（遍历的同时，将节点变"扁平"），直到找到代表节点3'
    比较1'和3'是否是同一个节点：答案不是
(3)将2和4所在的集合合并
    将4的代表节点3'，直接挂在2的代表节点1'上
