【红黑树的性质】
    （1）树的节点只有红色和黑色
    （2）根节点/叶子节点必须是黑色 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
    （3）红色节点不能是父子关系
    （4）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。[每个节点的黑高度相同]
【红黑树的平衡度】：一个结点的左右两颗子树的高度相差最多一倍。
     极端情况下，一颗子树a中全部都是黑色结点，另一颗子树b中则是红黑相间，由于它们的黑高相同，
所以b中的红色结点与黑色结点的数量相同，因此b的高度是a的两倍。
【时间复杂度】
    查找/插入/删除的时间复杂度都是O(lgN),与AVL树一样
【AVL树和RB-Tree的性能对比】
    (1)查询效率: AVL更加平衡，查询效率更高
    (2)插入/删除效率: AVL树要进行大量旋转调整，而红黑树的旋转最多可在3次搞定
        AVL需要维护从被插入和删除node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，
        RB-Tree最多只需3次旋转，旋转只需要O(1)的复杂度
    AVL更加适用于读取；维护起来更慢
    RB_Tree读取稍慢，维护起来更强大
    ---->RB_Tree并不追求"完全平衡"，降低了对"旋转"的要求
【使用场景】
        STL中的map/set
        Unix网络编程中的IO多路复用中的epoll
【插入时的旋转操作】
旋转操作(插入节点X)
黑父：直接插入
红父：3种情况——
        case1-红叔：则对父亲/叔叔/祖父节点重新上色，将祖父节点设为当前节点X，直到当前节点为根节点停止（最后将根节点变黑）
        黑叔：
            case2- 将x的父节点作为新的当前节点，旋转新的节点，进行【拉直】，拉直后变成case3
            case3- 对x的父节点/祖父节点重新上色；然后旋转祖父节点
            












