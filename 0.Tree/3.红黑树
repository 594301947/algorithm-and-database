【红黑树的性质】
    （1）树的节点只有红色和黑色
    （2）根节点/叶子节点必须是黑色 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
    （3）红色节点不能是父子关系
    （4）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。[每个节点的黑高度相同]
【红黑树的平衡度】：一个结点的左右两颗子树的高度相差最多一倍。
     极端情况下，一颗子树a中全部都是黑色结点，另一颗子树b中则是红黑相间，由于它们的黑高相同，
所以b中的红色结点与黑色结点的数量相同，因此b的高度是a的两倍。
【时间复杂度】
    查找/插入/删除的时间复杂度都是O(lgN),与AVL树一样
【AVL树和RB-Tree的性能对比】
    (1)查询效率: AVL更加平衡，查询效率更高
    (2)插入/删除效率: AVL树要进行大量旋转调整，而红黑树的旋转最多可在3次搞定
        AVL需要维护从被插入和删除node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，
        RB-Tree最多只需3次旋转，旋转只需要O(1)的复杂度
    AVL更加适用于读取；维护起来更慢
    RB_Tree读取稍慢，维护起来更强大
    ---->RB_Tree并不追求"完全平衡"，降低了对"旋转"的要求
【使用场景】
        STL中的map/set
        Unix网络编程中的IO多路复用中的epoll
        
http://www.cnblogs.com/skywang12345/p/3245399.html#aa5
==>【插入时的旋转操作】插入节点X必然是红色节点
Case 0 黑父
    直接插入 
Case 1 红父红叔
    父/叔变黑，祖父变红
    当前节点指向祖父，继续向上操作
    
Case 2 红父红黑/右孩子 
    父节点设为新的当前节点
    新的当前节点“右旋转”
Case 3 红父红黑/左孩子 
    将“父节点”设为“黑色”
    将“祖父节点”设为“红色”
    以“祖父节点”为支点进行“右旋”
 









