1.B树和B+树
  多路平衡查找树

2.M路B树和B+树的性质
B树：
  根节点：子树个数[2~M]   
  中间节点：子树个数[M/2]~M，包含数据 --->K个节点有K+1个子树
  叶子节点：不包含信息
B+树：
  根节点：子树个数[2,M]
  中间节点：子树个数[M/2]~M，不包含数据 ---->K个节点有K个子树
  叶子节点：包含数据，形成双链表
不同点：
    [0]B+树节点中的K关键字对应K个子树，而B树是K个关键字对应K+1个子树
    [1]中间节点：B+树只是索引，不含数据信息    
    [2]叶子节点：B+树保存数据，形成链表
    
注解：B树也有它的优点——由于B树的中间节点存放着数据，因此不用像B+树那样，每次都要从root查找节点

3.B树的高度——不包含最后不带任何信息的叶子节点所处的那一层

4.1B树的查找：与二叉排序树很相似，只不过每个节点都是多个关键字的"有序表"
    1.每个节点都是有序表，先从有序表中查找元素，查找失败，向该节点的指针下面查找
    2.反复过程1，直到查找到元素；如果查找位置到达叶子节点，则查找失败
4.2B+树的查找
    与B树不同，当查找到叶子节点时，由于B+树的所有数据都存放在叶子节点&&B+树的
叶子节点形成双链表，之后沿着双链表继续向后遍历查找
与B树对比：
    在查找区间[a,b]时，比B树更加快速
    因为查找到a时，直接通过双向链表，向后遍历即可

5.B树的插入：以┌m/2┐为分界点——由于每个节点的关键字的个数┌m/2┐-1，m - 1
    [i]  当插入后后，关键字的个数小于等于M-1，则直接插入
    [ii] 当插入后后，关键字的个数大于M-1，则必须进行分裂，过程见下：
            -先插入关键字到节点
            -以该节点中第┌m/2┐号关键字为分界线，进行分裂：
                    ┌m/2┐号关键字放到该节点的父亲节点中
                    剩下的部分分裂——1~┌m/2┐和┌m/2┐+1~m-1
6.B树的删除
  ~当删除的节点K不在终端节点：
        [1] 如果待删除元素K的前后子树节点中的关键字个数有一个 > ┌m/2┐-1， 则可用前驱K'或后继K'直接替换，再递归的删除K‘
        [2] 如果待删除元素K的前后子树节点中的关键字个数都 = ┌m/2┐-1，则先合并两个子节点，再删除K

  ~当删除的节点K在终端节点
        [1]K所在节点关键字的个数 > ┌m/2┐-1，则直接删除
        [2]K所在节点关键字的个数 = ┌m/2┐-1，
                -兄弟够借
                -兄弟不够借，进行合并 
      
