
https://blog.csdn.net/yixianfeng41/article/details/53689303

使用哈希表的情况
实现原理
哈希函数的选择原则
哈希冲突

======================

使用哈希表的情况：
(1)STL中的unordered_
(2)数据库中的索引——>哈希索引||B+树索引

1.实现原理：
    给一个key，经过一个哈希函数，再mod S后，会映射到一个S域

2.哈希函数的选择原则：
        1、数字分析法
          如果事先知道关键字集合，并且每个关键字的位数比哈希表的地址码位数多时，可以从关键字中选出分布较均匀的若干位，构成哈希地址。
        2、平方取中法
          当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。
        这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址。
        3、分段叠加法 
          这种方法是按哈希表地址位数将关键字分成位数相等的几部分（最后一部分可以较短），然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。
        具体方法有折叠法与移位法。移位法是将分割后的每部分低位对齐相加，折叠法是从一端向另一端沿分割界来回折叠（奇数段为正序，偶数段为倒序），
        然后将各段相加。
        4、除留取余法
          假设哈希表长为m，p为小于等于m的最大素数，则哈希函数为 
        hash（k）=k % p ，其中%为模p取余运算。
        5、伪随机数法
          采用一个伪随机函数做哈希函数，即h(key)=random(key)。
        6、直接定制法
          取关键字的某个线性函数作为散列函数，Hash(key)=A*key+B; 
        但是这种方法有很大的缺陷，就是当关键码比较分散时，hash表的所浪费的空间是非常大的。

3.哈希冲突：
    不同的key，映射到S域相同的位置，会产生冲突
4.如何解决哈希冲突：
    [开放定址法]：Hi=(H(key)+di) MOD m,使用某种算法，求出的key如果冲突，就继续采用该算法再次计算，直到找到不冲突的位置
        (1)线性探测 hash(key)+1,hash(key)+2, .... hash(key)+i
            在线性探测中，冲突时通过顺序往后一个一个扫描数组(如果到达尾端，就绕道头部继续寻找)，直到找到空的位置。
        (2)线性补偿探测
            将线性探测的步长从 1 改为 Q ，Q是与m互质的，这样便能探测到哈希表中左右单元。
        (3)二次探测 hash(key)+1^2,hash(key)+2^2, .... hash(key)+i^2
            二次探测，其命名来源是其解决碰撞问题的方程式是二次的F（i）=i^2.它不像线性探测那样顺序往后找，而是平方，平方的，这样就解决了扎堆问题。
            这个方法的缺点就是，会有大量元素扎堆，形成“主集团”，导致局部大规模发生冲突。
    [链地址法]：不同key映射到S域的相同位置，用链表的方式串联起来
    [再哈希法]:
        同时构造多个不同的哈希函数。当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。
        这种方法不易产生聚集，但增加了计算时间。
    [建立公共溢出区]:
        将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表

