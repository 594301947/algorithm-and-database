面试官：索引的数据结构？
我：bitmap，哈希索引，B+树索引
面试官：分别介绍下每种结构
我：
(1)bitmap
    是一个bit类型的数组，占用空间非常小---->创建和删除非常快
    每个bit位只能表示0和1状态----->不适用于键值较多，不适合update、insert、delete频繁的列
(2)哈希索引
    是一种<key,value>：key通过哈希函数，再mod S，映射到S域
    冲突，冲突如何解决？
优点：速度非常快，只需要直接经过哈希函数在O(1)定位到S域中的位置
      不需要向B+树索引那样，需要从根节点到叶子节点的逐级查找
缺点：不适用于以下几种情况————>
    (1)等值查询：== !=  IN  需要先找到该值所在的S域的位置；再遍历链表，直到找到相应的数据
    (2)排序相关的查询
        范围查询：此时哈希表就毫无用武之地了，因为原先有序的key，经过哈希函数后，可能变得不连续
        不能利用索引完成排序：与范围查询一样
        模糊查询：像like 'xxx%'，其实本质上也是范围查询
(3)B+树索引
1.介绍B+树---->平衡的多路查找树
2.一颗M阶的B树，5个性质
    子树个数
        [1]树中的每个节点至多有M个子树
        [2]根节点至少有2个子树
        [3]中间节点至少有[m/2]个子树
    节点上存的数据的大小
        [4]与BST二叉排序树存储数据的方式类似，左<中<右
        [5]所有的叶子节点都在一个层上，并且不带任何信息
3.之前存在一个非常大的误区
    每个节点上都存放着多个数，节点和节点之间是怎么相连的呢？
          实际上每个节点都有一个头指针，是通过节点的头指针与节点的头指针相连的
3.B树中查询key的过程
    [1]从root节点开始，由于root节点只有一个数据，因此直接比较大小即可
          如果key>root.data，查找root的右子树
          如果key<root.data，查找root的左子树
    [2]假设继续查找root的右子树，如何继续查找
          cur从root->right的头指针开始遍历，如果
              找到key==cur.data,直接返回true
              如果pre.data<key<cur.data,则向下查找


