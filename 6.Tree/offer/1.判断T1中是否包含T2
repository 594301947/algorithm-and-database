
思想：
    1.先寻找T1中，与T2的根节点相同的点
    2.如果找到，就判断T1是否包含T2
    3.条件1或条件2有一个不符合，就递归T1的左子树和右子树
#include <iostream>
using namespace std;
typedef struct TreeNode{
	struct TreeNode* left;
	struct TreeNode* right;
	int data;
}TreeNode;
//使用前序遍历创建一颗二叉树
TreeNode* createByPre(){
	int data;
	cin >> data;
	if (data == 0) //输入值为0
		return NULL;
	TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
	newNode->data = data;
	newNode->left = createByPre();
	newNode->right = createByPre();
	return newNode;
}
//T1中包含T2
bool judge(TreeNode* T1, TreeNode* T2){
	if (!T2)
		return true;
	if (T1&&T2&&T1->data == T2->data) //如果当前节点符合条件，则递归向下判断
		return judge(T1->left, T2->left) && judge(T1->right, T2->right);
	return false;
}
bool judgeT1T2(TreeNode* T1, TreeNode* T2){
	bool ret = false;
	if (T1 && T2){
		if (T1->data == T2->data)
			ret = judge(T1, T2); //根节点T1
		if (ret == false)
			ret = judgeT1T2(T1->left, T2); //左子树T1->left
		if (ret == false)
			ret = judgeT1T2(T1->right, T2); //右子树T1->right
	}
	return ret;
}
int main(){
	TreeNode* T1 = createByPre(); //1 2 4 0 0 0 3 5 0 0 6 0 0 
	TreeNode* T2 = createByPre(); //3 5 0 0 0
	bool ret = judgeT1T2(T1, T2);
}

