判断一棵二叉树T是否为对称二叉树：
   if  T==NULL，则return true；
   if  T!=NULL，则问题转变为：判断T1->left和T2->right是否是相等二叉树

#include <iostream>
using namespace std;
typedef struct TreeNode{
	struct TreeNode* left;
	struct TreeNode* right;
	int data;
}TreeNode;
//使用前序遍历创建一颗二叉树
TreeNode* createByPre(){
	int data;
	cin >> data;
	if (data == 0) //输入值为0
		return NULL;
	TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
	newNode->data = data;
	newNode->left = createByPre();
	newNode->right = createByPre();
	return newNode;
}

bool judge(TreeNode* T1, TreeNode* T2){
	if (!T1 && !T2)
		return true;
	if (T1&&T2&&T1->data == T2->data)
		return judge(T1->left, T2->right) && judge(T1->right, T2->left);
	return false;
}
bool isSame(TreeNode* T){
	if (T == NULL)
		return true;
	return judge(T->left, T->right);
}
int main(){
	TreeNode* T1 = createByPre(); //1 2 4 0 0 0 2 0 4 0 0-->true
	bool ret = isSame(T1);
}
