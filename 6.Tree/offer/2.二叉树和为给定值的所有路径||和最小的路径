题目1：二叉树和为给定值的所有路径
题目2：有一个普通的二叉树，求从根节点到叶子节点的和最小的路径

==================================

题目1：二叉树和为给定值的所有路径
vector<vector<int>> ret;
int cnt = 0;
vector<int> path;
void preOrder(TreeNode* T, int sum){//先序遍历
	if (T == NULL)
		return;
	
	//1.将T的元素加入path和cnt
	path.emplace_back(T->data);	cnt += T->data;
	
	if (!T->left && !T->right && cnt == sum) //2.满足条件
			ret.emplace_back(path);//path存入ret
	
	//3.如果左子树和右子树不是空，就遍历左右子树
	if (T->left)
		preOrder(T->left, sum);
	if (T->right)
		preOrder(T->right, sum);

	/*4.节点访问后，递归函数将自动回到它的父节点-->在函数退出前要在路径上删除
	当前节点&&减去当前节点的值*/
	path.pop_back(); cnt -= T->data;
}

int main(){
	 TreeNode* T = createByPre(); //10 5 12 0 0 7 0 0 12 0 0
	 int sum = 22;
	 preOrder(T, sum);
	 for (auto i = ret.begin(); i != ret.end(); i++){
		 for (auto j = i->begin(); j != i->end(); j++){
			 cout << *j << "  ";
		 }
		 cout << endl;
	 }
}

===============================

题目2：有一个普通的二叉树，求从根节点到叶子节点的和最小的路径
vector<int> path;
int cnt = 0;
int MaxCnt = INT_MIN;
vector<int> ret;
void preOrder(TreeNode* T){
	if (!T)
		return;
	path.push_back(T->data); cnt += T->data;
	if (!T->left && !T->right){ //叶子节点
		if (MaxCnt < cnt){
			ret = path; MaxCnt = cnt;
		}
	}

	if (T->left)
		preOrder(T->left);
	if (T->right)
		preOrder(T->right);
	path.pop_back(); cnt -= T->data;
}
int main(){
	TreeNode* T = createByPre(); //10 5 4 0 0 7 0 0 13 0 0
	preOrder(T);
	for (auto i = ret.begin(); i != ret.end(); i++){
		cout << *i << "  ";
	}
}
