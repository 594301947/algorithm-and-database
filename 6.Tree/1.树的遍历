#include<iostream>
#include<stack>
#include<queue>
using namespace std;

typedef struct TreeNode{
	int data;
	struct TreeNode* left;
	struct TreeNode* right;
}TreeNode;

/*-----(先/中/后)遍历-----*/
void PreTravel(TreeNode* T){
	if (T){
		printf("%d", T->data);
		PreTravel(T->left);
		PreTravel(T->right);
	}
}
void OrderTravel(TreeNode* T){
	if (T){
		OrderTravel(T->left);
		printf("%d", T->data);
		OrderTravel(T->right);
	}
}
void PostTravel(TreeNode* T){
	if (T){
		PostTravel(T->left);
		PostTravel(T->right);
		printf("%d", T->data);
	}
}
/*非递归遍历
1.都是在pop时搞事情: 打印 | 进辅助栈
2.中序: 先将所有的左孩子全部进栈
3.先序/后序的唯一区别: 
	(1)后序有辅助栈help
	(2)push时: 先序是先右孩子再左孩子；后序是先左孩子再右孩子
	(3)pop时: 先序是打印；后序是进辅助栈
*/
void PreTravelUnRecur(TreeNode* T){
	if (T == NULL)
		return;
	stack<TreeNode*> S;
	S.push(T);
	while (!S.empty()){
		TreeNode* p = S.top(); S.pop(); printf("%d  ", p->data);
		if (p->right)
			S.push(p->right);
		if (p->left)
			S.push(p->left);
	}
}
void OrderTravelUnRecur(TreeNode* T){
	if (T == NULL)
		return;
	stack<TreeNode*> S;
	TreeNode* p = T;
	while (p || !S.empty()){
		if (p){
			S.push(p); p = p->left;
		}
		else{
			p = S.top(); S.pop(); printf("%d  ", p->data);
			p = p->right;
		}
	}
}
void PostTravelUnRecur(TreeNode* T){
	if (T == NULL)
		return;
	stack<TreeNode*> S;
	stack<TreeNode*> help;

	S.push(T);
	while (!S.empty()){
		TreeNode* p = S.top(); S.pop(); help.push(p);
		if (p->left)
			S.push(p->left);
		if (p->right)
			S.push(p->right);
	}
	while (!help.empty()){
		TreeNode* tmp = help.top(); help.pop(); printf("%d  ", tmp->data);
	}
}
