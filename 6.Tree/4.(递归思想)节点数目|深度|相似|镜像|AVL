4.(递归思想)节点数目|深度|相似|镜像


主要考察的知识点： 递归思想
(1)列出可能性
(2)整理出返回值的类型
(3)整个递归过程按照同一个套路，得到子树的信息，整合子树的信息，加工出我的信息，向上返回
	我会遍历每一个节点，考虑以每个节点为头的整棵树
	左树和右树收集什么信息，是需要自己想的
	接下来怎么写代码，完全套路的


/*
1.节点数目:总结点/叶子节点
2.树深度:最大深度/最小深度
3.判断两树是否相似 
4.镜像：交换左右子树

5.判断一棵树是否为AVL树
6.求完全二叉树的总结点个数

7.判断是否为BST树
*/

//1.1求节点总数
int NodeCount(TreeNode* T){
	if (T == NULL)
		return 0;
	return 1 + NodeCount(T->left) + NodeCount(T->right);
}
//1.2求叶子节点总数
int leafCount(TreeNode* T){
	if (T == NULL) //如果T为NULL
		return 0;
	else if (T->left == NULL && T->right == NULL)//如果T的左右子树都为NULL
		return 1;
	else//如果T至少有一个孩子
		return leafCount(T->left) + leafCount(T->right);
}
//2.1树的高度
int height(TreeNode* T){
	if (T == NULL)
		return 0;
	int l = height(T->left);
	int r = height(T->right);
	return 1 + (l > r ? l : r);
}
//2.2树的最小深度
int minHeight(TreeNode* T){
	if (T == NULL) //如果T为NULL
		return 0;
	int l = minHeight(T->left);
	int r = minHeight(T->right);
	if (l == 0 || r == 0) //如果T的左右子树有一个为NULL
		return 1 + l + r;
	return 1 + (l < r ? l : r); //如果T的左右子树都不是NULL
}
//3.判断两棵树是否相似
bool isSimilar(TreeNode* T1, TreeNode*T2){
	if (T1 == NULL && T2 == NULL) //T1和T2都空
		return true;
	if (T1 != NULL && T2 != NULL){ //T1和T2都不是空
		return (isSimilar(T1->left, T2->left) && isSimilar(T1->right, T2->right));
	}
	else //T1和T2一个为空，一个为不空
		return false;
}
//4.交换树的左右子树(二叉树的镜像)
void swapTree(TreeNode* T){  
	if (T == NULL)
		return;
	//1.再交换T
	TreeNode* tmp = T->left;
	T->left = T->right;
	T->right = tmp;
	//2.先交换T的左右子树
	swapTree(T->left);
	swapTree(T->right);
}

/*5.判断是否是平衡二叉树
	(1)每个节点都要收集两个信息:class ReturnValue
		以该节点为根的树，是否为AVL树:bool flag
		以该节点为根的树的高度:int height
	(2)列出条件
		if T是空
		else
			递归求T->left，判断是否是AVL
			递归求T->right，判断是否是AVL
			T->left和T->right都平衡
				if 二者高度差>1:
				return new ReturnValue(true,1+max(左H,右R))；
*/
class ReturnValue{
public:
	ReturnValue(bool flag, int height) :flag(flag), height(height){}
public:
	bool flag;
	int height;
};
ReturnValue* process(TreeNode* T){
	if (T == NULL)
		return new ReturnValue(true, 0);
	ReturnValue* Lret = process(T->left);
	if (Lret->flag == false)
		return new ReturnValue(false, -1);
	ReturnValue* Rret = process(T->right);
	if (Rret->flag == false)
		return new ReturnValue(false, -1);

	//左右子树都平衡
	if (abs(Lret->height - Rret->height) > 1)
		return new ReturnValue(false, -1);
	return new ReturnValue(true, 
		1 + (Lret->height > Rret->height ? Lret->height : Rret->height));
}
bool isAVL(TreeNode* T){
	return process(T)->flag;
}

/*6.求完全二叉树的总结点个数:要求时间复杂度"低于"O(N)
	先求T的左子树和右子树的深度:LHeight RHeight
	if LHeightRHeight:
		说明左子树满
	else:
		说明右子树满
*/
int countCompleteNode(TreeNode* T){
	if (T == NULL)
		return 0;
	//1.求T的左子树的深度:即T->left的左子树
	int LHeight = 0;
	TreeNode* Lc = T;
	while (Lc->left){
		LHeight++;
		Lc = Lc->left;
	}
	//2.求T的右子树的深度:即T->right的最左节点
	int RHeight = 0;
	if (T->right){
		RHeight++;
		TreeNode* Rc = T->right;
		while (Rc->left){
			RHeight++;
			Rc = Rc->left;
		}
	}
	
	if (LHeight == RHeight){//3.左子树满
		//左子树的节点数+根节点
		int LCnt = (pow(2, LHeight) - 1) + 1;
		//递归计算右子树的节点个数
		return LCnt + countCompleteNode(T->right);
	}
	else{ //4.右子树满
		//右子树的节点数+根节点
		int RCnt = (pow(2, RHeight) + 1) - 1;
		//递归计算左子树的节点数
		return RCnt + countCompleteNode(T->left);
	}
}

//7.题目:判断一棵树是否为"搜索二叉树"


