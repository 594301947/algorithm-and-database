（1）前序遍历创建二叉树
（2）遍历：前，中，后，层



#include<iostream>
#include<stack>
#include<queue>
using namespace std;

typedef struct TreeNode{
	int data;
	struct TreeNode* left;
	struct TreeNode* right;
}TreeNode;

//使用前序遍历创建一颗二叉树
TreeNode* createByPre(){
	int data;
	cin >> data;
	if (data == 0) //输入值为0
		return NULL;
	TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
	newNode->data = data;
	newNode->left = createByPre();
	newNode->right = createByPre();
	return newNode;
}

/*-----(先/中/后)遍历-----*/
void PreTravel(TreeNode* T){
	if (T){
		printf("%d  ", T->data);
		PreTravel(T->left);
		PreTravel(T->right);
	}
}
void InOrderTravel(TreeNode* T){
	if (T){
		InOrderTravel(T->left);
		printf("%d  ", T->data);
		InOrderTravel(T->right);
	}
}
void PostTravel(TreeNode* T){
	if (T){
		PostTravel(T->left);
		PostTravel(T->right);
		printf("%d  ", T->data);
	}
}
/*非递归遍历*/
void preOrder(TreeNode* T){ //先序遍历
	if (T == NULL)
		return;
	stack<TreeNode*> S;
	TreeNode* p = T;
	while (p || !S.empty()){
		if (p){
			S.push(p); printf("%d  ", p->data);
			p = p->left;
		}
		else{
			p = S.top(); S.pop();
			p = p->right;
		}
	}
}
void inOrder(TreeNode* T){//中序遍历
	if(T == NULL)
		return;
	stack<TreeNode*> S;
	TreeNode* p = T;
	while (p || !S.empty()){
		if (p){
			S.push(p); 
			p = p->left;
		}
		else{
			p = S.top(); S.pop(); printf("%d  ", p->data);
			p = p->right;
		}
	}
}
void PostTravelUnRecur(TreeNode* T){//后序遍历
	if (T == NULL)
		return;
	stack<TreeNode*> S;
	stack<TreeNode*> help; //多了一个辅助栈help

	S.push(T);
	while (!S.empty()){
		TreeNode* p = S.top(); S.pop(); help.push(p); //数据不打印，让数据进辅助栈help
		if (p->left)   //先左
			S.push(p->left);
		if (p->right)  //后右
			S.push(p->right);
	}
	while (!help.empty()){ //将help打印
		TreeNode* tmp = help.top(); help.pop(); printf("%d  ", tmp->data);
	}
}


/*-----层序遍历-----*/
//二叉树的宽度优先遍历
void LevelTravel(TreeNode* T){
	if (T == NULL)
		return;
	queue<TreeNode*> Q;
	Q.push(T);
	while (!Q.empty()){
		TreeNode* cur = Q.front(); Q.pop(); printf("%d  ", cur->data);
		if (cur->left)
			Q.push(cur->left);
		if (cur->right)
			Q.push(cur->right);
	}
}
//层序遍历时，连同行号也打印
void LevelTravelPrintLevelNo_1(TreeNode* T){
	if (!T)
		return;
	queue<TreeNode*> Q;

	TreeNode* last; //当cur==last时，换行，换行时更新last=nlast
	TreeNode* nlast=NULL;//[nlast用于更新last,每次向队列push节点时，nlast指向新增加的节点]

	last = T; //显而易见，初始时last=T

	Q.push(T);
	while (!Q.empty()){
		TreeNode* cur = Q.front(); Q.pop(); cout << cur->data << "  ";
		if (cur->left){
			Q.push(cur->left);
			nlast = cur->left;//迭代的nlast
		}
		if (cur->right){
			Q.push(cur->right);
			nlast = cur->right;//迭代的nlast
		}
		if (cur == last){
			printf("\n");
			last = nlast;
		}
	}
}
//层序遍历时，连同行号也打印
vector<vector<int>> LevelTravelPrintLevelNo_2(TreeNode* T){
	if (!T)
		return vector<vector<int>>();

	vector<vector<int>> V;
	vector<int> subV;

	queue<TreeNode*> Q;

	TreeNode* last = T; //当cur==last时，换行，换行时更新last=nlast
	TreeNode* nlast=NULL;//[nlast用于更新last,每次向队列push节点时，nlast指向新增加的节点]
	Q.push(T);
	
	while (!Q.empty()){
		TreeNode* cur = Q.front(); Q.pop(); subV.push_back(cur->data);  
		if (cur->left){
			Q.push(cur->left);
			nlast = cur->left;//迭代的nlast
		}
		if (cur->right){
			Q.push(cur->right);
			nlast = cur->right;//迭代的nlast
		}
		if (cur == last){
			V.push_back(subV);
			subV.clear();
			last = nlast;
		}
	}
	return V;
}

void test01(){
	TreeNode* T = createByPre(); //input: 1 2 0 4 0 0 3 5 0 0 0
	vector<vector<int>> ret = LevelTravelPrintLevelNo_2(T);
	cout << "(逐行)层序遍历" << endl;
	for (int i = 0; i < ret.size(); i++){
		for (int j = 0; j < ret[i].size(); j++)
			cout << ret[i][j] << "   ";
		cout << endl;
	}
}
int main(){
	test01();
	system("pause");
}
