Top K Frequent Elements (Medium)
  Given [1,1,1,2,2,3] and k = 2, return [1,2].

/*
使用哈希表|桶排序(链表)
	1.哈希表进行词频统计:统计每个"数字key""出现的次数value"
	2.建立桶[bucket:list类型的数组]:bucket[i]的i表示出现次数
		假设元素出现次数是i，则添加到bucket[i]链表中
	3.全部将哈希表中的数，加入到桶中后，从后向前遍历哈希表
		找出桶中的前K个元素，就是topKFrequent
*/

#include<iostream>
#include<list>
#include<unordered_map>
using namespace std;

list<int> topKFrequent(int A[], int N, int k){
	list<int> ret;

	unordered_map<int, int> map;
	//1.遍历一遍A[i]，使用哈希表进行词频统计
	for (int i = 0; i < N; i++)
		map[A[i]] = map[A[i]] + 1; //key:数字， value:数字key出现的次数

	//2.创建N个桶，每个桶存放的元素是list
	list<int>* bucket = new list<int>[N + 1]; 
	for (auto node : map){
		int key = node.first;//取出key
		int cnt = node.second;//取出key出现的次数cnt
		//使用cnt，将元素key加入到桶中
		bucket[cnt].push_back(key);
	}
	//3.从后向前遍历一次桶，取出k个元素，即为出现频率最多的k个数
	for (int i = N; i >= 0 && k>0; i--){
		while (bucket[i].size() > 0){
			int elem = bucket[i].front(); bucket[i].pop_front();
			ret.push_back(elem); k--;
		}
	}
	return ret;
}

int main(){
	int A[] = { 1, 1, 1, 2, 2, 3 };
	int N = sizeof(A) / sizeof(A[0]);
	int K = 2;
	topKFrequent(A, N, K);
}
