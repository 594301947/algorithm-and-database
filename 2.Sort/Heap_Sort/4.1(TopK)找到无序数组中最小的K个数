找到无序数组中前K小的数，要求：时间复杂度—O(N*logK)或者O(N)
解法一O(N*logK)：使用优先级队列提供的堆
分析：
（1）首先拿前K个数建立大根堆
（2）遍历剩下的K+1~N号元素A[i]，分为下面两种情况:
        [1]如果A[i]大于或等于堆顶元素，则i++，继续向后遍历
        [2]如果A[i]小于堆顶元素，swap(A[i],堆顶元素)
（3）直到遍历完成第N个数，此时:堆中的元素，即为所有数组中最小的K个数，打印输出即可
#include<iostream>
#include<queue>
using namespace std;
vector<int> TopKmin(int A[], int N, int K){
	priority_queue<int> PQ; //建立大根堆
	for (int i = 0; i < K; i++)  //前K个数建立大根堆 O(N)
		PQ.push(A[i]);
	for (int i = K; i < N;){ //O(N-K)*O(lgK) 
		if (A[i] >= PQ.top()) //如果A[i]大于或等于堆顶元素
			i++;
		else{
			PQ.top() = A[i]; //O(lgK) 直接将堆顶元素用A[i]替换，替换完自动调整成堆
			i++;
		}
	}
	//此时遍历完所有的数，堆中的元素就是前K小个数
	vector<int> Ret;
	while (!PQ.empty()){
		Ret.push_back(PQ.top()); //将堆顶元素压入Vector
		PQ.pop();
	}
	return Ret;
}

int main()
{
	int A[] = { 1,3,2,5,4,8,7,9,6,10 };
	int N = sizeof(A) / sizeof(A[0]);
	int K = 5;

	vector<int> Ret = TopKmin(A, N, K);
	for (auto node : Ret)
		cout << node << "   ";
	system("pause");
}
