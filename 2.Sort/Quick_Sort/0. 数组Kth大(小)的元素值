
[**]快速排序最最最经典的问题，就是寻找Kth元素

该题有三种解法：
	堆排:O(N*lgK)
	快排:O(N)

求数组A中第K小的元素（从小到大排序后，处于第K个位置的元素值） 
分析：QSort每一趟排序可以确定一个基准pivotPos的最终位置，直接看代码

int partition(int A[], int l, int r) //QSort的划分操作
{
	int pivot = A[l];
	while (l < r)
	{
		while (l < r && A[r] >= pivot)
			r--;
		A[l] = A[r];
		while (l < r && A[l] <= pivot)
			l++;
		A[r] = A[l];
	}
	A[l] = pivot;
	return l;
}
int search_min_K(int A[], int l, int r, int K)
{
	//if(l < r)  一定不能加上
	{
		int pos = partition(A, l, r);
		int m = pos - l + 1;   //m表示基准pos处于第几个位置
		if (m == K) //如果基准pos处于第K个位置，直接返回
			return A[pos];
		else if (m > K) //如果基准pos大于第K个位置，递归地从A[l,pos-1]中查找，第K个元素
			return search_min_K(A, l, pos - 1, K);
		else //如果基准pos小于第K个位置，递归地从A[pos+1,r]中查找，第K-m个元素
			return search_min_K(A, pos + 1, r, K - m);
	}
}
int main(){
	int A[] = { 14,13,12,11,1,3,2,4,6,5,7,9,8,10};
	int N = sizeof(A) / sizeof(A[0]);
	int Kth = 9;
	int ret = search_min_K(A, 0, N - 1, Kth);
}
