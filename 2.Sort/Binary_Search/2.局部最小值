题目：给定无序数组arr，已知arr中任意两个相邻的数都不相等，写一个函数，只需返回arr中任意一个局部最小出现的位置.

	定义局部最小的概念。
	arr长度为1时，arr[0]是局部最小。
	arr的长度为N(N>1)时，如果arr[0]<arr[1]，那么arr[0]是局部最小；
	如果arr[N-1]<arr[N-2]，那么arr[N-1]是局部最小；
	如果0<i<N-1，既有arr[i]<arr[i-1]又有arr[i]<arr[i+1]，那么arr[i]是局部最小。

//用"递减思想"---->两端"递减"，那么中间必然存在局部最小值
int getPartMinV(int A[], int N){
	if (N == 0) //1.如果没有数，说明没有局部最少
		return -1;
	if (N == 1)//2.如果只有一个数，返回A[0]
		return 0;
	//3.如果至少两个数，两种特殊情况
	if (A[0] < A[1]) //第一个数<第二个数
		return 0;
	if (A[N - 1] < A[N - 2])//最后一个数<倒数第二个数
		return N - 1;
	//如果情况1，2，3都不满足
	int l = 0, r = N - 1;
	while (l < r){
		int mid = l + (r - l) / 2;
		if (A[mid] < A[mid - 1] && A[mid] < A[mid + 1]) //如果mid小于两边的值
			return mid;
		else if (A[mid]>A[mid - 1] && A[mid] < A[mid + 1])//在[l,mid-1]之间，必然存在最小值
			r = mid - 1;
		else if (A[mid]<A[mid - 1] && A[mid] > A[mid + 1])//极大值点
			l = mid + 1;
		else
			r = mid - 1; //l = mid + 1   二者都可以
		
	}
}
