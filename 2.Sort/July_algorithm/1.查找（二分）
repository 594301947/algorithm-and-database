1.（相邻数不相等）（无序）数组，寻找一个局部最小值
2.
	（2.1）对于一个有序数组arr，再给定一个整数num，请在arr中找到num这个数出现的最左边的位置。
	（2.2）对于一个有序数组arr，再给定一个整数num，请在arr中找到num这个数出现的次数。
3.pow(K,N)
4.(一直看不明白）循环有序数组的最小值，查找元素X  (Leetcode153,154) ***

题型1：
1.（相邻数不相等）（无序）数组，寻找一个局部最小值
(1)A[0] A[1] ; A[N-2] A[N-1]
(2)
    A[i-1]   A[i]   A[i+1]   
           >      <     直接return A[i]
           >      >     右边查找      L=mid+1
           <      <     左边查找      R=mid-1
           <      >     两边都可以    L=mid+1或者R=mid-1

题型2:只与二分查找相差一行代码
（2.1）对于一个有序数组arr，再给定一个整数num，请在arr中找到num这个数出现的最左边的位置。
		if (A[mid] == num){
			r = mid - 1;  //与二分查找，仅仅此处不同——>记录相等时的mid；二分查找是直接return mid
			ret = mid; 
		}
（2.2）对于一个有序数组arr，再给定一个整数num，请在arr中找到num这个数出现的次数。
		if (A[mid] == mid){
			ret = mid;
			r = mid - 1;
		}

题型3：pow(K,N)
(1)K每次都平方
(2)逐位判断（指数N的二进制）是否为1，如果是1，就res=res*当前K的值
	int pow(int K,int N){
		int res=1;
		while(N){
		    if((N&1)==1)
		       res=res*K;

		    K=K*K;

		    N=(N>>1); //更新N
		}
		return res;
	}

题型4：(一直看不明白）循环有序数组的最小值，查找元素X  (Leetcode153,154)
    
