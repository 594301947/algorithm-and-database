必须保证小根堆中的最小元素 >= 大根堆中的最大元素
（即：小根堆的堆顶 >= 大根堆的堆顶）

依次取出流中的数vec[i]，向大根堆/小根堆中放：
1.先放入大根堆，再放入小根堆；再放入大根堆，再放入小根堆；... ...，直到全部放完
2.1将vec[i]放入大根堆之前，要拿小根堆的堆顶元素Top与vec[i]比较
	如果vec[i]<Top，则vec[i]直接放入大根堆
	如果vec[i]>Top，则将Top放入大根堆；将vec[i]放入小根堆
2.2将vec[i]放入大根堆，要拿大根堆的堆顶元素Top与vec[i]比较
	如果vec[i]>Top，则vec[i]直接放入大根堆
	如果vec[i]<Top，则将Top放入小根堆；将vec[i]放入大根堆


说明：本题目非常好，考察堆排序的使用
分析：从流中依次获取数num，放入大根堆和小根堆要保证下面规则：
(1)大根堆中的数 < 小根堆中的数
(2)保证大根堆和小根堆中元素个数的差不超过1
怎么保证呢？
if maxPQ.size() + minPQ.size() == 偶数:  //将num放入大根堆
	比较num和minPQ.top()的大小
	     当num较大时，将较小的minPQ.top()放入maxPQ
	     当num较小时，num直接进maxPQ
if maxPQ.size() + minPQ.size() == 奇数:  //将num放入小根堆
	比较num和maxPQ.top()的大小
	     当num小于maxPQ.top()时，将较大的maxPQ.top放入minPQ
	     当num较大时，直接将num放入minPQ
	     
#include<iostream>
#include<functional>
#include<vector>
#include<queue>
using namespace std;

//大根堆和小根堆

class Solution {
public:
		void Insert(int num){
		int maxSize = maxPQ.size();
		int minSize = minPQ.size();
		if ((maxSize + minSize) % 2 == 0){ //偶数，进大根堆
			if (minSize > 0 && num > minPQ.top()){
                maxPQ.push(minPQ.top()); minPQ.pop();
				minPQ.push(num);
			}
			else{
				maxPQ.push(num);
			}
		}
		else{ //奇数，进小根堆
			if (maxSize > 0 && num < maxPQ.top()){
				minPQ.push(maxPQ.top()); maxPQ.pop();
				maxPQ.push(num);
			}
			else
				minPQ.push(num);
		}
	}
	double GetMedian(){
		vector<int> Ret;
		if ((maxPQ.size() + minPQ.size()) % 2 != 0){//奇数
			Ret.push_back(maxPQ.top());
			return maxPQ.top();
		}
		else{
			Ret.push_back(minPQ.top());
			Ret.push_back(maxPQ.top());
			return (minPQ.top()+maxPQ.top())/2.0;
		}
	}
public:
	priority_queue<int> maxPQ;  //大根堆
	priority_queue<int, vector<int>, greater<int>> minPQ;  //小根堆
};
int main(){
	Solution obj;
	obj.Insert(11);
	obj.Insert(3);
	obj.Insert(4);
	obj.Insert(20);
	obj.Insert(5);
	obj.Insert(7);
	obj.Insert(6);
	vector<int> Ret = obj.GetMedian();
	for (int i = 0; i < Ret.size(); i++)
		cout << Ret[i] << endl;
	system("pause");
}
