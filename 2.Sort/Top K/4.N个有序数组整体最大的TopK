打印N个有序数组整体最大的TopK
例如，输入含有N行元素的二维数组可以代表N个一维数组
219，405，538，845，971
148，558
52，99，348，691
再输入整数k=5，则打印：
Top5: 971，845，691，558，538

1.构建一个大小为N的大顶堆，初始元素为每个有序数组的最后一个元素。调整初始堆。
2.打印当前堆顶元素，为最大的。
3.假设堆顶元素来自于a数组的i位置，接下来把堆顶元素的位于a数组的前一个元素a[i-1]放在堆顶，然后调整堆。
4.重复前两步，直到打印前K个。
5.在步骤3中，如果来自a数组的前一个元素已经不存在了，那么就把堆中最后一个元素放在堆顶位置，把heap大小减1，调整堆。


#include<iostream>
#include<vector>
#include<queue>
#include<functional>
using namespace std;

class HeapNode{
public:
	HeapNode(int ArrNum, vector<int>* ptr, int data) :
		ArrNum(ArrNum), ptr(ptr), data(data){}
	bool operator<(const HeapNode another) const{
		return this->data < another.data;
	}
public:
	int ArrNum; //当前有效数组的个数
	vector<int>* ptr; //来自哪一个数组
	int data;  //值是什么
};

//N个数组
vector<int> getTopK(vector<vector<int>> V, int topK){
	vector<int> Ret;

	int ArrNum = V.size(); //N个数组，就构建大小为N的大根堆
	priority_queue<HeapNode> PQ; //大根堆

	//1.以每个数组的最后一个元素，建立初始大小为N的大顶堆
	for (int i = 0; i<ArrNum; i++){
		//将V[i]中的元素取出来，放入PQ
		PQ.push(HeapNode(ArrNum, &V[i], V[i].back())); V[i].pop_back();
	}
	while (topK-- > 0){
		if (ArrNum == 0)
			break;
		HeapNode elem = PQ.top(); PQ.pop();//2.取出堆顶元素（就是所有数组的最大值）
		Ret.push_back(elem.data); 
		
		vector<int>* ptr = elem.ptr; //从哪个数组取出的元素
		if (ptr->size() != 0){ //如果该数组不是空
			PQ.push(HeapNode(ArrNum, ptr, ptr->back())); ptr->pop_back();//将ptr中的元素取出来，放入PQ
		}
		else //从ptr取走数据后，如果ptr数组变空
			ArrNum--; //则当前有效数组个数减一
	}
	return Ret;
}

void func(int data){
	cout << data << "   ";
}
int main(){
	vector<vector<int>> V = { { 219, 405, 538, 845, 971 },
	{ 148, 558 }, { 52, 99, 348, 691 } };

	vector<int> ret = getTopK(V, 433);

	for_each(ret.begin(), ret.end(),func);
	system("pause");
}
