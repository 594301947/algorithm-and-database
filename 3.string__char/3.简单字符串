1.T1是否具有T2拓扑结构完全相同的子树
  普通解法：二叉树遍历+匹配问题 O（M*N）
    思想：考察T1的每一个节点为头的子树，是否和T2一致
    步骤：依次遍历T1每一个节点，
            与T2依次对比，
                如果拓扑结构相同，返回true
                如果不同，继续遍历T1的下一个节点
            直到T1遍历结束
  最优解：二叉树序列化+KMP算法O（M+N）
      T1序列化str1，T2序列化str2
      str1中寻找str2：KMP
          如果包含，返回true
          否则，返回false
          
2.str1和str2互为旋转词： 最优解时间O(N)
    1.先判断长度是否相等
    2.生成[str1+str1]大的字符串
    3.用KMP算法在大的字符串[str1+str1]中查找是否包含str2
====================
【活用{局部逆序函数}的组合】void reverse(string str,int l,int r);
  
3. pig loves dog ---> dog loves pig
    1.先实现任意范围的逆序[l,r]
    2.
        str整体逆序
        找到逆序后的单词区域，将每个单词逆序

4.给定str和i，i代表str中的位置
要求：将str[0,i-1]移动到右侧，str[i+1,N-1]移动到左侧
    时间O(N)，空间O(1)
举例：str="ABCDE",i=2----->DEABC
分析：由于空间O(1)，因此不能使用额外的char数组保存--->必须进行原地交换
    [0,i-1]局部逆序:CBA DE
    [i,N-1]局部逆序：CBA ED
    整体逆序DEABC
====================
5.[字典序]给定一个字符串数组strs，进行拼接，使拼接后的字符串形成的大字符串的字典顺序最小，并返回这个大字符串
    (1)设定比较规则：a+b < b+a  --->  a在前，b在后
    (2)进行排序
====================
6.str1和str2互为变形词：
  str1和str2的每个字符的种类一样，并且每种字符出现的次数也一样
解：时间O(N)空间O(N)
  哈希表：str1和str2的分别词频统计
  比对
